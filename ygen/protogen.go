// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package ygen

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"text/template"

	"github.com/openconfig/goyang/pkg/yang"
)

// protoMsgField describes a field of a protobuf message.
type protoMsgField struct {
	Tag        uint32            // Tag is the field number that should be used in the protobuf message.
	Name       string            // Name is the field's name.
	Type       string            // Type is the protobuf type for the field.
	IsRepeated bool              // IsRepeated indicates whether the field is repeated.
	Extensions map[string]string // Extensions is the set of field tags that are applied to the field.
}

// protoMsg describes a protobuf message.
type protoMsg struct {
	Name     string           // Name is the name of the protobuf message to be output.
	YANGPath string           // YANGPath stores the path that the message corresponds to within the YANG schema.
	Fields   []*protoMsgField // Fields is a slice of the fields that are within the message.
	Imports  []string         // Imports is a slice of strings that contains the relative import paths that are required by this message.
}

// proto3Header describes the header of a Protobuf3 package.
type proto3Header struct {
	PackageName            string   // PackageName is the name of the package that is to be output.
	BasePackageName        string   // BasePackageName is the base package, of which the package is a child package.
	BaseImportPath         string   // BaseImportPath specifies the path to generated protobufs that are to be imported by this protobuf, for example, the base repository URL in GitHub.
	Imports                []string // Imports is the set of packages that should be imported by the package whose header is being output.
	SourceYANGFiles        []string // SourceYANGFiles specifies the list of the input YANG files that the protobuf is being generated based on.
	SourceYANGIncludePaths []string // SourceYANGIncludePaths specifies the list of the paths that were used to search for YANG imports.
	CompressPaths          bool     // CompressPaths indicates whether path compression was enabled or disabled for this generated protobuf.
	CallerName             string   // CallerName indicates the name of the entity initiating code generation.
}

const (
	// defaultBasePackageName defines the default base package that is
	// generated when generating proto3 code.
	defaultBasePackageName = "openconfig"
)

var (
	// protoHeaderTemplate is populated and output at the top of the protobuf code output.
	protoHeaderTemplate = `
{{- /**/ -}}
// {{ .PackageName }} is generated by {{ .CallerName }} as a protobuf
// representation of a YANG schema.
//
// Input schema modules:
{{- range $inputFile := .SourceYANGFiles }}
//  - {{ $inputFile }}
{{- end }}
// Include paths:
{{- range $importPath := .SourceYANGIncludePaths }}
//   - {{ $importPath }}
{{- end }}
syntax = "proto3";

package {{ .PackageName }};

import "github.com/openconfig/ygot/proto/ywrapper/ywrapper.proto";
import "github.com/openconfig/ygot/proto/yext/yext.proto";
{{ $publicImport := .BaseImportPath -}}
{{- range $importedProto := .Imports }}
import "{{ filepathJoin $publicImport $importedProto }}.proto";
{{ end -}}
`

	// protoMessageTemplate is populated for each entity that is mapped to a message
	// within the output protobuf.
	protoMessageTemplate = `
// {{ .Name }} represents the {{ .YANGPath }} YANG schema element.
message {{ .Name }} {
{{- range $idx, $field := .Fields }}
  {{ if $field.IsRepeated }}repeated {{ end -}}
  {{ $field.Type }} {{ $field.Name }} = {{ $field.Tag }}
  {{- $noExtensions := len .Extensions -}}
  {{- if ne $noExtensions 0 -}} [
    {{- range $i, $opt := $field.Extensions -}}
      {{- $opt -}}
      {{- if ne (inc $i) $noExtensions -}}, {{- end }}
   {{- end -}}
  ]
  {{- end -}}
  ;
{{- end }}
}`

	// protoTemplates is the set of templates that are referenced during protbuf
	// code generation.
	protoTemplates = map[string]*template.Template{
		"header": makeTemplate("header", protoHeaderTemplate),
		"msg":    makeTemplate("msg", protoMessageTemplate),
	}
)

// writeProto3Header outputs the header for a proto3 generated file. It takes
// an input proto3Header struct specifying the input arguments describing the
// generated package, and returns a string containing the generated package's
// header.
func writeProto3Header(in proto3Header) (string, error) {
	if in.CallerName == "" {
		in.CallerName = callerName()
	}

	if in.BasePackageName == "" {
		in.BasePackageName = defaultBasePackageName
	}

	if in.PackageName == "" {
		in.PackageName = in.BasePackageName
	} else {
		in.PackageName = fmt.Sprintf("%s.%s", in.BasePackageName, in.PackageName)
	}

	var b bytes.Buffer
	if err := protoTemplates["header"].Execute(&b, in); err != nil {
		return "", err
	}

	return b.String(), nil
}

// writeProto3Msg generates a protobuf message for the *yangDirectory described by msg.
// it uses the context of other messages to be generated (msgs), and the generator
// state stored in state to determine names of other messages. compressPaths indicates
// whether path compression should be enabled for the code generation. Returns a string
// containing the name of the package that the message is within, a string containing
// the generated code for the protobuf message, a slice of strings containing the child
// packages that are required by this message and any errors encountered during
// proto generation.
func writeProto3Msg(msg *yangDirectory, msgs map[string]*yangDirectory, state *genState, compressPaths bool) (string, string, []string, []error) {
	msgDef, errs := genProto3Msg(msg, msgs, state, compressPaths)
	if errs != nil {
		return "", "", nil, errs
	}

	if msg.entry.Parent == nil {
		return "", "", nil, []error{fmt.Errorf("YANG schema element %s does not have a parent, protobuf messages are not generated for modules", msg.entry.Path())}
	}

	// pkg is the name of the protobuf package, if the entry's parent has already
	// been seen in the schema, the same package name as for siblings of this
	// entry will be returned.
	pkg := state.protobufPackage(msg.entry, compressPaths)

	var b bytes.Buffer
	if err := protoTemplates["msg"].Execute(&b, msgDef); err != nil {
		return "", "", nil, []error{err}
	}

	return pkg, b.String(), msgDef.Imports, nil

}

// genProto3Msg takes an input yangDirectory which describes a container or list entry
// within the YANG schema and returns a protoMsg which can be mapped to the protobuf
// code representing it. It uses the set of messages that have been extracted and the
// current generator state to map to other messages and ensure uniqueness of names.
func genProto3Msg(msg *yangDirectory, msgs map[string]*yangDirectory, state *genState, compressPaths bool) (protoMsg, []error) {
	var errs []error

	msgDef := protoMsg{
		// msg.name is already specified to be CamelCase in the form we expect it
		// to be for the protobuf message name.
		Name:     msg.name,
		YANGPath: slicePathToString(msg.path),
	}

	definedFieldNames := map[string]bool{}
	imports := []string{}

	// Traverse the fields in alphabetical order to ensure deterministic output.
	// TODO(robjs): Once the field tags are unique then make this sort on the
	// field tag.
	fNames := []string{}
	for name := range msg.fields {
		fNames = append(fNames, name)
	}
	sort.Strings(fNames)

	for _, name := range fNames {
		field := msg.fields[name]

		fieldDef := &protoMsgField{
			Name: makeNameUnique(safeProtoFieldName(name), definedFieldNames),
		}

		t, err := protoTagForEntry(field)
		if err != nil {
			errs = append(errs, fmt.Errorf("proto: could not generate tag for field %s: %v", field.Name, err))
			continue
		}
		fieldDef.Tag = t

		switch {
		case field.IsList():
			err = fmt.Errorf("proto: list generation unimplemented for %s", field.Path())
		case field.IsDir():
			childmsg, ok := msgs[field.Path()]
			if !ok {
				err = fmt.Errorf("proto: could not resolve %s into a defined struct", field.Path())
			} else {

				childpkg := state.protobufPackage(childmsg.entry, compressPaths)

				// Add the import to the slice of imports if it is not already
				// there. This allows the message file to import the required
				// child packages.
				childpath := strings.Replace(childpkg, ".", "/", -1)
				var found bool
				for _, i := range imports {
					if i == childpath {
						found = true
					}
				}
				if !found {
					imports = append(imports, childpath)
				}
				fieldDef.Type = fmt.Sprintf("%s.%s", childpkg, childmsg.name)
			}
		case field.IsLeaf() || field.IsLeafList():
			var protoType mappedType
			protoType, err = state.yangTypeToProtoType(resolveTypeArgs{yangType: field.Type, contextEntry: field})
			fieldDef.Type = protoType.nativeType

			if field.ListAttr != nil {
				fieldDef.IsRepeated = true
			}
		default:
			err = fmt.Errorf("proto: unknown field type in message %s, field %s", msg.name, field.Name)
		}

		if err != nil {
			errs = append(errs, err)
			continue
		}
		msgDef.Fields = append(msgDef.Fields, fieldDef)
	}

	// Append the deduplicated imports to the list of imports required for the
	// message.
	msgDef.Imports = imports

	return msgDef, errs
}

// safeProtoFieldName takes an input string which represents the name of a YANG schema
// element and sanitises for use as a protobuf field name.
func safeProtoFieldName(name string) string {
	// YANG identifiers must match the definition:
	//    ;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))
	//       identifier          = (ALPHA / "_")
	//                                *(ALPHA / DIGIT / "_" / "-" / ".")
	// For Protobuf they must match:
	//	ident = letter { letter | decimalDigit | "_" }
	//
	// Therefore we need to ensure that the "-", and "." characters that are allowed
	// in the YANG are replaced.
	replacer := strings.NewReplacer(
		".", "_",
		"-", "_",
	)
	return replacer.Replace(name)
}

// fieldTag returns a protobuf tag value for the entry e. The tag value supplied is
// between 1 and 2^29-1. The values 19,000-19,999 are excluded as these are explicitly
// reserved for protobuf-internal use by https://developers.google.com/protocol-buffers/docs/proto3.
func protoTagForEntry(e *yang.Entry) (uint32, error) {
	// TODO(robjs): Replace this function with the final implementation
	// once concluded.
	return 1, nil
}
